<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0f1419" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="manifest" href="/manifest.json" />
    <title>Bot Development Guide - Fog of War</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/shared.css">
    <style>
        .container {
            max-width: 1000px;
        }
        
        .warning {
            background: #fed7d7;
            border: 1px solid #fc8181;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .info {
            background: #bee3f8;
            border: 1px solid #63b3ed;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            border: 1px solid #e2e8f0;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background: #edf2f7;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/" class="back-link">‚Üê Back to Home</a>
        
        <h1>Bot Development Guide</h1>
        
        <div class="info">
            <strong>Note:</strong> This documentation is for creating bots for the <a href="https://fog-of-war-0f4f.onrender.com/">Fog of War</a> game server.
        </div>
        
        <h2>üöÄ Quick Start</h2>
        
        <h3>1. Install Dependencies</h3>
        <pre><code>npm install socket.io-client</code></pre>
        
        <h3>2. Enhanced Bot Template</h3>
        <pre><code>const io = require('socket.io-client');

// Connect to our game server
const socket = io('https://fog-of-war-0f4f.onrender.com');

// Bot state
let playerIndex = -1;
let gameMap = [];
let generals = [];
let cities = [];

// Set bot username and join a game
const botName = 'MyBot';
const gameRoom = 'test';
const userId = `bot_${Date.now()}`;

socket.emit('set_username', userId, botName);
socket.emit('join_private', gameRoom, userId);

// Listen for game start
socket.on('game_start', (data) => {
    playerIndex = data.playerIndex;
    console.log(`Game started! Player index: ${playerIndex}`);
});

// Listen for game updates
socket.on('game_update', (data) => {
    // Update game state using patch function
    cities = patch(cities, data.cities_diff);
    gameMap = patch(gameMap, data.map_diff);
    generals = data.generals; // Only shows your general + discovered enemy generals
    
    // Track current turn
    const currentTurn = data.turn;
    console.log(`Turn ${currentTurn}: Processing game update`);
    
    // Check for newly discovered enemy generals
    for (let i = 0; i < generals.length; i++) {
        if (i !== playerIndex && generals[i] !== -1) {
            console.log(`Enemy general discovered at position ${generals[i]}!`);
        }
    }
    
    // Make a move
    makeMove();
});

// Simple move logic
function makeMove() {
    const { width, height, armies, terrain, towerDefense } = parseMap();
    
    // Find tiles with armies > 1
    for (let i = 0; i < terrain.length; i++) {
        if (terrain[i] === playerIndex && armies[i] > 1) {
            const adjacent = getAdjacentTiles(i, width, height);
            
            for (const adj of adjacent) {
                // Expand to empty tiles or attack weaker enemies
                if (terrain[adj] === -1 || 
                    (terrain[adj] >= 0 && terrain[adj] !== playerIndex && 
                     armies[i] > armies[adj] + 1)) {
                    socket.emit('attack', i, adj);
                    return;
                }
            }
        }
    }
}

// Parse enhanced map data
function parseMap() {
    const width = gameMap[0];
    const height = gameMap[1];
    const size = width * height;
    const armies = gameMap.slice(2, size + 2);
    const terrain = gameMap.slice(size + 2, size * 2 + 2);
    const towerDefense = gameMap.slice(size * 2 + 2, size * 3 + 2);
    return { width, height, armies, terrain, towerDefense };
}

// Patch function for differential updates
function patch(old, diff) {
    const result = [...old];
    let i = 0;
    while (i < diff.length) {
        const start = diff[i++];
        const deleteCount = diff[i++];
        const newItems = diff.slice(i, i + deleteCount);
        result.splice(start, deleteCount, ...newItems);
        i += deleteCount;
    }
    return result;
}

// Get adjacent tile indices
function getAdjacentTiles(index, width, height) {
    const row = Math.floor(index / width);
    const col = index % width;
    const adjacent = [];
    
    if (row > 0) adjacent.push(index - width);
    if (row < height - 1) adjacent.push(index + width);
    if (col > 0) adjacent.push(index - 1);
    if (col < width - 1) adjacent.push(index + 1);
    
    return adjacent;
}

console.log(`Bot ${botName} connecting to game ${gameRoom}...`);</code></pre>
        
        <h2>üì° Socket.IO API Reference</h2>
        
        <div class="api-section">
            <h3>Outgoing Events (Bot ‚Üí Server)</h3>
            
            <h4><code>set_username</code></h4>
            <p>Set the bot's username</p>
            <pre><code>socket.emit('set_username', userId, username);</code></pre>
            
            <h4><code>join_private</code></h4>
            <p>Join a private game room</p>
            <pre><code>socket.emit('join_private', gameId, userId);</code></pre>
            
            <h4><code>attack</code></h4>
            <p>Move armies from one tile to another</p>
            <pre><code>socket.emit('attack', fromTileIndex, toTileIndex);</code></pre>
            
            <h4><code>set_force_start</code></h4>
            <p>Start the game (host only)</p>
            <pre><code>socket.emit('set_force_start', gameId, true);</code></pre>
            
            <h4><code>chat_message</code></h4>
            <p>Send a chat message</p>
            <pre><code>socket.emit('chat_message', {
    gameId: gameId,
    message: 'Hello!',
    username: botName
});</code></pre>
            
            <h4><code>leave_game</code></h4>
            <p>Leave the current game</p>
            <pre><code>socket.emit('leave_game', gameId, userId);</code></pre>
        </div>
        
        <div class="api-section">
            <h3>Incoming Events (Server ‚Üí Bot)</h3>
            
            <h4><code>game_start</code></h4>
            <p>Game has started</p>
            <pre><code>socket.on('game_start', (data) => {
    // data.playerIndex - your player index (-1 for spectators)
    // data.replay_id - game ID for replay
    // data.mapData - initial map state
});</code></pre>
            
            <h4><code>game_update</code></h4>
            <p>Game state update (every 100ms during game)</p>
            <pre><code>socket.on('game_update', (data) => {
    // data.cities_diff - differential city updates
    // data.map_diff - differential map updates
    // data.lookoutTowers_diff - differential tower updates
    // data.generals - general positions array
    // data.players - player info array
    // data.turn - current game turn/tick number
});</code></pre>
            
            <h4><code>game_won</code></h4>
            <p>Game ended</p>
            <pre><code>socket.on('game_won', (data) => {
    // data.winner - winning player index
});</code></pre>
            
            <h4><code>player_joined</code></h4>
            <p>Player list updated</p>
            <pre><code>socket.on('player_joined', (data) => {
    // data.players - updated player array
    // data.newPlayerIndex - index of newly joined player
});</code></pre>
            
            <h4><code>chat_message</code></h4>
            <p>Chat message received</p>
            <pre><code>socket.on('chat_message', (data) => {
    // data.username - sender username
    // data.message - message text
    // data.playerIndex - sender's player index
    // data.timestamp - message timestamp
    // data.isSystem - true for system messages
});</code></pre>
            
            <h4><code>attack_result</code></h4>
            <p>Attack success/failure feedback</p>
            <pre><code>socket.on('attack_result', (data) => {
    // data.from - source tile
    // data.to - target tile
    // data.success - whether attack succeeded
});</code></pre>
            
            <h4><code>game_info</code></h4>
            <p>Host and spectator information</p>
            <pre><code>socket.on('game_info', (data) => {
    // data.spectatorCount - number of spectators
    // data.hostName - current host username
    // data.hostSocketId - host socket ID
});</code></pre>
            
            <h4>Error Events</h4>
            <pre><code>socket.on('username_taken', (data) => {
    // Username already in use
});

socket.on('game_already_started', () => {
    // Cannot join - game in progress
});

socket.on('game_start_error', (message) => {
    // Game start failed with reason
});</code></pre>
        </div>
        
        <h2>üó∫Ô∏è Game Mechanics</h2>
        
        <div class="info">
            <strong>Recent Updates:</strong> The game now features enhanced lookout tower mechanics with maximum spawning, permanent vision, and mobile-specific fog interaction.
        </div>
        
        <h3>Map Data Structure</h3>
        <p>The game map is represented as a flat array where each index represents a tile:</p>
        
        <table>
            <tr>
                <th>Array</th>
                <th>Description</th>
            </tr>
            <tr>
                <td><code>armies</code></td>
                <td>Number of armies on each tile</td>
            </tr>
            <tr>
                <td><code>terrain</code></td>
                <td>Tile ownership (-1: empty, -2: mountain, -5: tower, -6: city, 0+: player index)</td>
            </tr>
            <tr>
                <td><code>towerDefense</code></td>
                <td>Defense values for lookout towers (0 for non-tower tiles)</td>
            </tr>
            <tr>
                <td><code>generals</code></td>
                <td>General positions array with fog of war - only shows your own general and discovered enemy generals (index = player, value = tile position or -1 if unknown)</td>
            </tr>
            <tr>
                <td><code>cities</code></td>
                <td>Array of city tile positions</td>
            </tr>
        </table>
        
        <h3>Tile Types</h3>
        <ul>
            <li><strong>Empty (-1):</strong> Neutral territory, can be captured</li>
            <li><strong>Mountain (-2):</strong> Impassable terrain</li>
            <li><strong>Lookout Tower (-5):</strong> Defensive structure with towerDefense value (10 defense). <em>New: Maximum towers spawn with no overlapping 5-tile vision radius</em></li>
            <li><strong>City (-6):</strong> Neutral city, generates armies when captured</li>
            <li><strong>Player Territory (0+):</strong> Owned by player with that index</li>
        </ul>
        
        <h3>Movement Rules</h3>
        <ul>
            <li>Can only move from tiles you own</li>
            <li>Can only move to adjacent tiles (up, down, left, right)</li>
            <li>Must leave at least 1 army on the source tile</li>
            <li>Moving to enemy territory = attack</li>
            <li>Moving to your own territory = reinforcement</li>
        </ul>
        
        <h3>Combat Mechanics</h3>
        <ul>
            <li><strong>Regular Combat:</strong> Attacker wins if armies > defender armies</li>
            <li><strong>Lookout Towers:</strong> Must overcome towerDefense value (10) to capture. <em>New: Provides permanent vision of 5-tile radius once captured</em></li>
            <li><strong>Cities:</strong> Start with 40 armies, generate 1 army per turn when captured</li>
            <li><strong>Generals:</strong> Generate 1 army per turn, capturing eliminates player. <em>Enemy generals are hidden by fog of war until discovered!</em></li>
        </ul>
        
        <h3>Army Generation</h3>
        <ul>
            <li><strong>Generals:</strong> +1 army every turn</li>
            <li><strong>Cities:</strong> +1 army every turn when owned</li>
            <li><strong>Regular Territory:</strong> +1 army every 25 turns</li>
        </ul>
        
        <h3>Fog of War System</h3>
        <ul>
            <li><strong>Enemy Generals:</strong> Hidden until discovered through combat or adjacent territory</li>
            <li><strong>Discovery Methods:</strong> Attack enemy territory, expand adjacent to enemy generals, or capture enemy tiles</li>
            <li><strong>Strategic Importance:</strong> Must actively search for and discover enemy positions</li>
            <li><strong>Fair Play:</strong> All players (bots and humans) have equal information - no cheating!</li>
        </ul>
        
        <h3>Victory Conditions</h3>
        <ul>
            <li>Capture all enemy generals</li>
            <li>Be the last player standing</li>
        </ul>
        
        <h2>üõ†Ô∏è Advanced Bot Development</h2>
        
        <h3>Map Parsing</h3>
        <pre><code>function parseMapData(mapData) {
    const width = mapData[0];
    const height = mapData[1];
    
    let index = 2;
    const armies = mapData.slice(index, index + width * height);
    index += width * height;
    
    const terrain = mapData.slice(index, index + width * height);
    index += width * height;
    
    // Parse generals and cities arrays...
    
    return { width, height, armies, terrain, generals, cities };
}</code></pre>
        
        <h3>Pathfinding</h3>
        <pre><code>function getAdjacentTiles(tileIndex, width, height) {
    const row = Math.floor(tileIndex / width);
    const col = tileIndex % width;
    const adjacent = [];
    
    // Up
    if (row > 0) adjacent.push(tileIndex - width);
    // Down  
    if (row < height - 1) adjacent.push(tileIndex + width);
    // Left
    if (col > 0) adjacent.push(tileIndex - 1);
    // Right
    if (col < width - 1) adjacent.push(tileIndex + 1);
    
    return adjacent;
}</code></pre>
        
        <h3>Strategy Tips</h3>
        <ul>
            <li><strong>Early Game:</strong> Expand quickly to claim territory and cities</li>
            <li><strong>City Priority:</strong> Capture cities for consistent army generation</li>
            <li><strong>Tower Strategy:</strong> Build up armies before attacking towers (10 defense). <em>New: Capturing towers provides permanent vision advantage</em></li>
            <li><strong>Mid Game:</strong> Build army strength and discover enemy generals through exploration and combat</li>
            <li><strong>Late Game:</strong> Focus attacks on discovered enemy generals</li>
            <li><strong>Defense:</strong> Keep armies near your general</li>
            <li><strong>Economy:</strong> Cities and generals provide steady army growth</li>
            <li><strong>Vision Control:</strong> <em>New: Prioritize tower capture for permanent map vision and strategic advantage</em></li>
            <li><strong>Enemy Discovery:</strong> <em>Critical: Actively search for enemy generals through expansion and combat - they're hidden by fog of war!</em></li>
        </ul>
        
        <h3>Advanced Bot Features</h3>
        
        <h4>Chat Integration</h4>
        <pre><code>// Send chat messages
socket.emit('chat_message', {
    gameId: gameRoom,
    message: 'Good luck!',
    username: botName
});

// Listen for chat
socket.on('chat_message', (data) => {
    if (!data.isSystem) {
        console.log(`${data.username}: ${data.message}`);
    }
});</code></pre>
        
        <h4>Host Controls</h4>
        <pre><code>// Start game as host
socket.emit('set_force_start', gameRoom, true);

// Listen for host status
socket.on('game_info', (data) => {
    if (data.hostName === botName) {
        console.log('I am the host!');
    }
});</code></pre>
        
        <h4>Enhanced Map Parsing</h4>
        <pre><code>function parseEnhancedMap(mapData) {
    const width = mapData[0];
    const height = mapData[1];
    const size = width * height;
    
    const armies = mapData.slice(2, size + 2);
    const terrain = mapData.slice(size + 2, size * 2 + 2);
    const towerDefense = mapData.slice(size * 2 + 2, size * 3 + 2);
    
    return { width, height, armies, terrain, towerDefense };
}

// Identify tile types
function getTileType(terrain, index) {
    const value = terrain[index];
    if (value === -1) return 'empty';
    if (value === -2) return 'mountain';
    if (value === -5) return 'tower';
    if (value === -6) return 'city';
    if (value >= 0) return 'player';
    return 'unknown';
}</code></pre>
        
        <div class="warning">
            <strong>Important:</strong> Bots should implement proper error handling and reconnection logic 
            for production use. The game server may restart or experience network issues.
        </div>
        
        <h2>üîó Example Bots</h2>
        <p>Check out our example bot implementation:</p>
        <ul>
            <li><strong><a href="https://github.com/Sirrine-Jonathan/fog-of-war-bot" target="_blank">Fog of War Bot</a>:</strong> Complete TypeScript bot with expansion, attack logic, and reconnection handling</li>
        </ul>
        
        <div class="footer">
            <a href="/" class="back-link">‚Üê Back to Home</a>
        </div>
    </div>
    <script src="/logMessage.js"></script>
    <script src="/optionsManager.js"></script>
    <script src="/soundManager.js"></script>
    <script src="/konami.js"></script>
</body>
</html>
