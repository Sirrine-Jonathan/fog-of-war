<!DOCTYPE html>
<html>
<head>
    <title>Fog of War</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        #gameContainer { 
            display: flex; 
            gap: 30px; 
            background: rgba(255,255,255,0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }
        
        #gameBoard { 
            border: 3px solid #333; 
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        #info { 
            min-width: 250px;
            background: rgba(255,255,255,0.8);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .fog { 
            background: repeating-linear-gradient(
                45deg,
                #888,
                #888 2px,
                #999 2px,
                #999 4px
            );
            opacity: 0.8;
        }
        
        .castle {
            position: relative;
        }
        
        .castle::before {
            content: 'üè∞';
            position: absolute;
            top: -2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            z-index: 10;
        }
        
        .player0 { background-color: #ff6b6b; }
        .player1 { background-color: #4ecdc4; }
        .player2 { background-color: #45b7d1; }
        .player3 { background-color: #96ceb4; }
        .empty { background-color: #f0f0f0; }
        .mountain { background-color: #333; color: white; }
        .selected { border: 3px solid #ffd700 !important; box-shadow: 0 0 10px #ffd700; }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        #gameEndModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 400px;
            position: relative;
        }
        
        .close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #aaa;
        }
        
        .close:hover {
            color: #000;
        }
        
        .winner-text {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }
        
        .game-info {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .players-list {
            background: rgba(255,255,255,0.9);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>Fog of War</h1>
    <div id="gameContainer">
        <div>
            <canvas id="gameBoard" width="500" height="375"></canvas>
            <div style="margin-top: 15px; text-align: center;">
                <p style="color: #666; font-size: 14px;">Click a tile you own, then click an adjacent tile to attack/move</p>
                <p style="color: #333; font-weight: 600;">Selected tile: <span id="selectedTile">None</span></p>
            </div>
        </div>
        <div id="info">
            <div class="game-info">
                <h3 style="margin-top: 0; color: #333;">Game Info</h3>
                <p><strong>Room:</strong> <span id="roomId"></span></p>
                <p><strong>Status:</strong> <span id="gameStarted">Waiting</span></p>
                <p><strong>Host:</strong> <span id="hostName">-</span></p>
                <p><strong>Spectators:</strong> <span id="spectatorCount">0</span></p>
                <div id="gameEndNotification" style="display: none; background: #f0f8ff; border: 2px solid #4CAF50; padding: 15px; margin: 10px 0; border-radius: 5px; text-align: center;">
                    <div id="gameEndText" style="font-weight: bold; font-size: 18px; margin-bottom: 10px;"></div>
                    <div style="font-size: 14px; color: #666;">Game has ended. Players can rejoin for the next game.</div>
                </div>
            </div>
            
            <div class="players-list">
                <h4 style="margin-top: 0; color: #333;">Players</h4>
                <div id="players"></div>
            </div>
            
            <div>
                <input type="text" id="usernameInput" placeholder="Enter your username" style="width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 5px;">
                <button id="joinBtn" class="btn">üéÆ Join as Player</button>
                <button id="startBtn" class="btn">üöÄ Start Game</button>
            </div>
        </div>
    </div>

    <!-- Game End Modal -->
    <div id="gameEndModal">
        <div class="modal-content">
            <span class="close" onclick="closeGameEndModal()">&times;</span>
            <div class="winner-text" id="winnerText"></div>
            <p id="gameEndMessage"></p>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const canvas = document.getElementById('gameBoard');
        const ctx = canvas.getContext('2d');
        const socket = io();
        
        let gameState = null;
        let selectedTile = null;
        let playerIndex = -1;
        let gameStarted = false;
        let players = [];
        let visibleTiles = new Set();
        let playerGenerals = new Map(); // Track each player's starting position
        let lastUsername = ''; // Remember last used username
        let isHost = false;
        let hostSocketId = null;
        let isEliminated = false;
        let playerSocketMap = new Map(); // playerIndex -> socketId
        
        // Get room ID from URL
        const roomId = window.location.pathname.split('/').pop();
        document.getElementById('roomId').textContent = roomId;
        
        // Persistence keys (defined after roomId)
        const STORAGE_KEY = `fog_of_war_${roomId}`;
        
        // Load persisted state
        function loadPersistedState() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const state = JSON.parse(saved);
                    lastUsername = state.username || '';
                    document.getElementById('usernameInput').value = lastUsername;
                    return state;
                } catch (e) {
                    console.warn('Failed to load persisted state:', e);
                }
            }
            return null;
        }
        
        // Save state to localStorage (only for actual players)
        function saveState() {
            if (playerIndex >= 0) { // Only save if actually joined as player
                const state = {
                    username: lastUsername,
                    playerIndex: playerIndex,
                    isHost: isHost,
                    timestamp: Date.now()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            }
        }
        
        // Clear saved state
        function clearState() {
            localStorage.removeItem(STORAGE_KEY);
        }
        
        // Auto-rejoin if we were previously in this game (only if we were a player)
        function attemptAutoRejoin() {
            const saved = loadPersistedState();
            if (saved && saved.username && saved.playerIndex >= 0 && (Date.now() - saved.timestamp < 30 * 60 * 1000)) { // 30 min timeout
                console.log('Attempting auto-rejoin for player:', saved.username);
                const userId = 'human_' + Date.now();
                socket.emit('set_username', userId, saved.username);
                socket.emit('join_private', roomId, userId);
            }
        }
        
        // Colors for players
        const playerColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'];
        const emptyColor = '#f0f0f0';
        const mountainColor = '#333';
        const fogColor = '#888';
        
        // Connect as viewer initially, then try auto-rejoin
        socket.emit('set_username', 'viewer_' + Date.now(), 'Viewer');
        socket.emit('join_private', roomId, 'viewer_' + Date.now());
        
        // Load persisted state and attempt auto-rejoin
        loadPersistedState();
        setTimeout(attemptAutoRejoin, 100); // Small delay to ensure connection
        
        socket.on('game_start', (data) => {
            console.log('Game started!', data);
            document.getElementById('gameStarted').textContent = gameStarted ? 'Playing' : 'Started';
            document.getElementById('gameEndNotification').style.display = 'none'; // Hide notification
            playerIndex = data.playerIndex !== undefined ? data.playerIndex : -1;
            gameStarted = true;
            updateButtonVisibility(); // Update button visibility
            saveState(); // Save state when game starts
            console.log('Player index set to:', playerIndex);
        });
        
        socket.on('game_info', (data) => {
            document.getElementById('spectatorCount').textContent = data.spectatorCount;
            document.getElementById('hostName').textContent = data.hostName || '-';
            hostSocketId = data.hostSocketId;
            
            // Update host status based on server data
            isHost = (data.hostSocketId === socket.id);
            console.log('Host status update:', { mySocketId: socket.id, hostSocketId: data.hostSocketId, isHost, playerIndex });
            
            // Update player socket mapping
            if (data.playerSocketMap) {
                playerSocketMap = new Map(Object.entries(data.playerSocketMap));
            }
            
            // Show/hide buttons based on status
            updateButtonVisibility();
        });
        
        function updateButtonVisibility() {
            const joinBtn = document.getElementById('joinBtn');
            const startBtn = document.getElementById('startBtn');
            
            // Hide join button if already joined as player
            joinBtn.style.display = (playerIndex >= 0) ? 'none' : 'inline-block';
            
            // Show start button only to host
            startBtn.style.display = isHost ? 'inline-block' : 'none';
        }
        
        socket.on('joined_as_player', (data) => {
            console.log('Joined as player:', data);
            playerIndex = data.playerIndex;
            saveState(); // Save state only after successfully joining
            updateButtonVisibility(); // Update button visibility
        });
        
        socket.on('player_joined', (data) => {
            console.log('Player joined:', data);
            players = data.players;
            
            // Only update playerIndex if this event is specifically about us joining
            // (Don't update when other players join)
            
            // Check if current player is eliminated
            if (playerIndex >= 0 && players[playerIndex]?.eliminated) {
                isEliminated = true;
                console.log('Player eliminated - switching to spectator view');
                updateVisibleTiles(); // Update visibility to show full map
                drawGame();
            }
            
            updatePlayersList();
        });
        
        socket.on('username_taken', (data) => {
            alert(`Username "${data.username}" is already taken. Please choose a different username.`);
            document.getElementById('usernameInput').focus();
        });
        
        socket.on('game_won', (data) => {
            gameStarted = false;
            const winnerName = players[data.winner]?.username || 'Unknown';
            
            // Reset player state for humans (bots will auto-rejoin)
            playerIndex = -1;
            selectedTile = null;
            document.getElementById('selectedTile').textContent = 'None';
            document.getElementById('gameStarted').textContent = 'Game Ended';
            
            // Show in-game notification instead of modal
            const notification = document.getElementById('gameEndNotification');
            const gameEndText = document.getElementById('gameEndText');
            
            // Check if current player won by comparing usernames
            const didIWin = (winnerName === lastUsername);
            
            if (didIWin) {
                gameEndText.textContent = 'üéâ Victory! You won the game! üéâ';
                gameEndText.style.color = '#4CAF50';
            } else {
                gameEndText.textContent = `üíÄ Game Over - ${winnerName} won! üíÄ`;
                gameEndText.style.color = '#f44336';
            }
            
            notification.style.display = 'block';
            
            // Pre-populate username input with last used username
            document.getElementById('usernameInput').value = lastUsername;
            
            // Clear saved state when game ends
            clearState();
        });
        
        socket.on('attack_result', (data) => {
            if (data.success) {
                selectedTile = data.to;
                document.getElementById('selectedTile').textContent = data.to;
                updateVisibleTiles();
                drawGame();
            } else {
                // Keep the original tile selected on failed moves
                // selectedTile remains unchanged
                drawGame();
            }
        });
        
        socket.on('game_update', (data) => {
            console.log('Game update received:', data);
            if (data.map_diff && data.map_diff.length > 0) {
                const patchedMap = patch([], data.map_diff);
                gameState = parseMapData(patchedMap);
                
                // Update players data if provided
                if (data.players) {
                    gameState.players = data.players;
                }
                
                // Check if current player got eliminated this turn
                if (playerIndex >= 0 && gameState.players && gameState.players[playerIndex]?.eliminated && !isEliminated) {
                    isEliminated = true;
                    console.log('Player just got eliminated - switching to spectator view');
                }
                
                // Track generals (starting positions)
                if (gameState && gameStarted) {
                    for (let i = 0; i < gameState.terrain.length; i++) {
                        const terrain = gameState.terrain[i];
                        if (terrain >= 0 && gameState.armies[i] > 0) {
                            // Check if this might be a starting position (high army count early in game)
                            if (!playerGenerals.has(terrain) && gameState.armies[i] >= 10) {
                                playerGenerals.set(terrain, i);
                            }
                        }
                    }
                }
                
                updateVisibleTiles();
                drawGame();
            }
        });
        
        function updateVisibleTiles() {
            if (!gameState) return;
            
            visibleTiles.clear();
            
            // Viewers and eliminated players see everything
            if (playerIndex < 0 || isEliminated) {
                for (let i = 0; i < gameState.terrain.length; i++) {
                    visibleTiles.add(i);
                }
                return;
            }
            
            // Active players see fog of war
            for (let i = 0; i < gameState.terrain.length; i++) {
                if (gameState.terrain[i] === playerIndex) {
                    visibleTiles.add(i);
                    
                    // Add adjacent tiles (8-directional including diagonals)
                    const adjacent = getAdjacentTiles(i);
                    adjacent.forEach(adj => visibleTiles.add(adj));
                }
            }
        }
        
        function getAdjacentTiles(tileIndex) {
            const adjacent = [];
            const row = Math.floor(tileIndex / gameState.width);
            const col = tileIndex % gameState.width;
            
            // 8-directional (including diagonals)
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue; // Skip the tile itself
                    
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < gameState.height && 
                        newCol >= 0 && newCol < gameState.width) {
                        adjacent.push(newRow * gameState.width + newCol);
                    }
                }
            }
            
            return adjacent;
        }
        
        function patch(old, diff) {
            const out = [];
            let i = 0;
            while (i < diff.length) {
                if (diff[i]) {
                    out.push(...old.slice(out.length, out.length + diff[i]));
                }
                i++;
                if (i < diff.length && diff[i]) {
                    out.push(...diff.slice(i + 1, i + 1 + diff[i]));
                    i += diff[i];
                }
                i++;
            }
            return out;
        }
        
        function parseMapData(mapData) {
            const width = mapData[0];
            const height = mapData[1];
            const size = width * height;
            const armies = mapData.slice(2, size + 2);
            const terrain = mapData.slice(size + 2, size + 2 + size);
            
            return { width, height, armies, terrain, generals: [] };
        }
        
        function drawGame() {
            if (!gameState) return;
            
            const tileSize = 25;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < gameState.terrain.length; i++) {
                const row = Math.floor(i / gameState.width);
                const col = i % gameState.width;
                const x = col * tileSize;
                const y = row * tileSize;
                
                // Check if tile is visible to current player
                const isVisible = playerIndex < 0 || visibleTiles.has(i);
                
                if (!isVisible) {
                    // Draw fog of war
                    ctx.fillStyle = fogColor;
                    ctx.fillRect(x, y, tileSize, tileSize);
                    
                    // Add fog pattern
                    ctx.fillStyle = '#999';
                    for (let fx = 0; fx < tileSize; fx += 4) {
                        for (let fy = 0; fy < tileSize; fy += 4) {
                            if ((fx + fy) % 8 === 0) {
                                ctx.fillRect(x + fx, y + fy, 2, 2);
                            }
                        }
                    }
                } else {
                    // Draw visible tile
                    const terrain = gameState.terrain[i];
                    if (terrain === -2) { // Mountain
                        ctx.fillStyle = mountainColor;
                    } else if (terrain >= 0) { // Player owned
                        ctx.fillStyle = playerColors[terrain] || emptyColor;
                    } else { // Empty
                        ctx.fillStyle = emptyColor;
                    }
                    
                    ctx.fillRect(x, y, tileSize, tileSize);
                    
                    // Draw castle for starting positions
                    if (playerGenerals.has(terrain) && playerGenerals.get(terrain) === i) {
                        ctx.fillStyle = '#8B4513'; // Brown castle base
                        ctx.fillRect(x + 8, y + 18, 9, 7);
                        ctx.fillRect(x + 6, y + 15, 4, 10);
                        ctx.fillRect(x + 15, y + 15, 4, 10);
                        ctx.fillRect(x + 10, y + 12, 5, 13);
                        
                        // Castle flag
                        ctx.fillStyle = playerColors[terrain];
                        ctx.fillRect(x + 11, y + 8, 3, 4);
                    }
                    
                    // Draw army count
                    if (gameState.armies[i] > 0) {
                        ctx.fillStyle = terrain === -2 ? 'white' : 'black';
                        ctx.font = 'bold 10px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(gameState.armies[i].toString(), x + tileSize/2, y + tileSize/2 + 3);
                    }
                }
                
                // Draw border
                ctx.strokeStyle = selectedTile === i ? '#ffd700' : '#ccc';
                ctx.lineWidth = selectedTile === i ? 3 : 1;
                ctx.strokeRect(x, y, tileSize, tileSize);
                
                // Add glow effect for selected tile
                if (selectedTile === i) {
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 10;
                    ctx.strokeRect(x, y, tileSize, tileSize);
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        function closeGameEndModal() {
            document.getElementById('gameEndModal').style.display = 'none';
        }

        function showGameEndModal(winnerName, winnerIndex) {
            const modal = document.getElementById('gameEndModal');
            const winnerText = document.getElementById('winnerText');
            const gameEndMessage = document.getElementById('gameEndMessage');
            
            console.log('Game end modal:', { winnerName, winnerIndex, myPlayerIndex: playerIndex, myUsername: lastUsername });
            
            // Check if current player won by comparing usernames instead of indices
            const didIWin = (winnerName === lastUsername);
            
            if (didIWin) {
                winnerText.textContent = 'üéâ Victory! üéâ';
                winnerText.style.color = '#4CAF50';
                gameEndMessage.textContent = 'Congratulations! You have conquered the battlefield!';
            } else {
                winnerText.textContent = 'üíÄ Defeat üíÄ';
                winnerText.style.color = '#f44336';
                gameEndMessage.textContent = `${winnerName} has conquered the battlefield. Better luck next time!`;
            }
            
            modal.style.display = 'flex';
        }
        
        canvas.addEventListener('click', (e) => {
            if (!gameState || playerIndex < 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const tileSize = 25;
            
            const col = Math.floor(x / tileSize);
            const row = Math.floor(y / tileSize);
            const tileIndex = row * gameState.width + col;
            
            // Only allow interaction with visible tiles
            if (!visibleTiles.has(tileIndex)) return;
            
            if (selectedTile === null) {
                // Select any tile owned by player (even with 1 army)
                if (gameState.terrain[tileIndex] === playerIndex) {
                    selectedTile = tileIndex;
                    document.getElementById('selectedTile').textContent = tileIndex;
                    drawGame();
                }
            } else {
                if (isAdjacent(selectedTile, tileIndex)) {
                    // Only attempt attack/move if we have enough armies
                    if (gameState.armies[selectedTile] > 1) {
                        socket.emit('attack', selectedTile, tileIndex);
                    } else {
                        // Can't move with only 1 army, but allow reselecting target if it's owned
                        if (gameState.terrain[tileIndex] === playerIndex) {
                            selectedTile = tileIndex;
                            document.getElementById('selectedTile').textContent = tileIndex;
                            drawGame();
                        }
                    }
                } else {
                    // Click on non-adjacent tile - select it if owned, otherwise clear selection
                    if (gameState.terrain[tileIndex] === playerIndex) {
                        selectedTile = tileIndex;
                        document.getElementById('selectedTile').textContent = tileIndex;
                    } else {
                        selectedTile = null;
                        document.getElementById('selectedTile').textContent = 'None';
                    }
                    drawGame();
                }
            }
        });
        
        function isAdjacent(from, to) {
            const fromRow = Math.floor(from / gameState.width);
            const fromCol = from % gameState.width;
            const toRow = Math.floor(to / gameState.width);
            const toCol = to % gameState.width;
            
            const rowDiff = Math.abs(fromRow - toRow);
            const colDiff = Math.abs(fromCol - toCol);
            
            return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
        }
        
        function updatePlayersList() {
            const playersDiv = document.getElementById('players');
            playersDiv.innerHTML = '';
            players.forEach((player, index) => {
                const div = document.createElement('div');
                div.style.color = playerColors[index] || 'black';
                div.style.padding = '5px';
                div.style.borderRadius = '5px';
                div.style.margin = '2px 0';
                div.style.background = 'rgba(255,255,255,0.7)';
                
                const status = player.eliminated ? ' üíÄ' : ' ‚öîÔ∏è';
                const type = player.isBot ? 'ü§ñ' : 'üë§';
                div.textContent = `${type} ${player.username}${status}`;
                
                if (player.eliminated) {
                    div.style.textDecoration = 'line-through';
                    div.style.opacity = '0.5';
                }
                
                if (index === playerIndex) {
                    div.style.fontWeight = 'bold';
                    div.style.border = '2px solid ' + (playerColors[index] || 'black');
                }
                
                // Add host transfer button for non-bot players (only visible to current host)
                if (isHost && !player.isBot && index !== playerIndex) {
                    const transferBtn = document.createElement('button');
                    transferBtn.textContent = 'üëë';
                    transferBtn.style.marginLeft = '10px';
                    transferBtn.style.fontSize = '12px';
                    transferBtn.style.padding = '2px 6px';
                    transferBtn.style.border = 'none';
                    transferBtn.style.borderRadius = '3px';
                    transferBtn.style.cursor = 'pointer';
                    transferBtn.title = 'Transfer host to this player';
                    transferBtn.onclick = () => transferHost(index);
                    div.appendChild(transferBtn);
                }
                
                playersDiv.appendChild(div);
            });
        }
        
        function transferHost(targetPlayerIndex) {
            const targetSocketId = playerSocketMap.get(targetPlayerIndex.toString());
            console.log('Transfer host attempt:', { targetPlayerIndex, targetSocketId, playerSocketMap });
            if (targetSocketId) {
                socket.emit('transfer_host', roomId, targetSocketId);
            } else {
                console.error('No socket ID found for player index:', targetPlayerIndex);
            }
        }
        
        // Button handlers
        document.getElementById('joinBtn').addEventListener('click', joinAsPlayer);
        document.getElementById('startBtn').addEventListener('click', startGame);
        
        function joinAsPlayer() {
            if (playerIndex >= 0) return;
            
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) {
                alert('Please enter a username');
                document.getElementById('usernameInput').focus();
                return;
            }
            
            lastUsername = username; // Remember this username
            const userId = 'human_' + Date.now();
            socket.emit('set_username', userId, username);
            socket.emit('join_private', roomId, userId);
        }
        
        function startGame() {
            socket.emit('set_force_start', roomId, true);
        }
        
        // Arrow key controls
        document.addEventListener('keydown', (e) => {
            if (!gameState || playerIndex < 0 || selectedTile === null) return;
            
            let targetTile = null;
            const row = Math.floor(selectedTile / gameState.width);
            const col = selectedTile % gameState.width;
            
            switch(e.key) {
                case 'ArrowUp':
                    if (row > 0) targetTile = selectedTile - gameState.width;
                    break;
                case 'ArrowDown':
                    if (row < gameState.height - 1) targetTile = selectedTile + gameState.width;
                    break;
                case 'ArrowLeft':
                    if (col > 0) targetTile = selectedTile - 1;
                    break;
                case 'ArrowRight':
                    if (col < gameState.width - 1) targetTile = selectedTile + 1;
                    break;
            }
            
            if (targetTile !== null && visibleTiles.has(targetTile)) {
                if (gameState.armies[selectedTile] > 1) {
                    // Have armies to move - attempt attack/move
                    socket.emit('attack', selectedTile, targetTile);
                } else if (gameState.terrain[targetTile] === playerIndex) {
                    // Can't move but target is owned - change selection
                    selectedTile = targetTile;
                    document.getElementById('selectedTile').textContent = targetTile;
                    drawGame();
                }
                e.preventDefault();
            }
        });
    </script>
</body>
</html>
